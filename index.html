<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Релакс Плейграунд — Агентство «Смысл»</title>
  <!-- Подключаем стили и шрифты -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* Reset и базовые стили */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: 'Inter', sans-serif; background: #0d1926; color: #fff; }
    button { background: none; border: none; cursor: pointer; }

    /* Меню выбора игр */
    #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; width: 80%; max-width: 1000px; }
    .game-btn { background: rgba(255,255,255,0.1); border: 2px solid #3fa9f5;
      border-radius: 16px; padding: 20px; text-align: center; transition: all 0.3s ease;
      display: flex; align-items: center; justify-content: center; height: 200px; }
    .game-btn:hover { background: rgba(63,169,245,0.2); transform: scale(1.05); }
    .game-btn span { font-size: 1.2rem; font-weight: 600; }

    /* Контейнер игры */
    #game-container, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; }
    #controls { position: absolute; top: 20px; left: 20px; z-index: 10; }
    #backBtn { padding: 10px 20px; background: #3fa9f5; color: #0d1926; border-radius: 8px; font-weight: 600; transition: background 0.3s ease; }
    #backBtn:hover { background: #61c1ff; }

    /* Стиль HUD для игр */
    .hud { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.3);
      padding: 10px 15px; border-radius: 8px; font-size: 1rem; }

    /* Общие анимации */
    .fade-in { animation: fadeIn 0.8s ease forwards; opacity: 0; }
    .slide-up { animation: slideUp 0.6s ease forwards; opacity: 0; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
  </style>
</head>
<body>
  <!-- Главное меню выбора игр -->
  <div id="menu">
    <div class="game-btn fade-in" data-game="bubbles"><span>Bubble Pop</span></div>
    <div class="game-btn fade-in" data-game="fishpond"><span>Fish Pond</span></div>
    <div class="game-btn fade-in" data-game="zengarden"><span>Zen Garden</span></div>
    <div class="game-btn fade-in" data-game="starfield"><span>Starfield</span></div>
    <div class="game-btn fade-in" data-game="colorflow"><span>Color Flow</span></div>
  </div>

  <!-- Контейнер для запуска игр -->
  <div id="game-container">
    <div id="controls" class="slide-up">
      <button id="backBtn">← Меню</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="hud" class="hud"></div>
  </div>

  <script>
  // === Инициализация ===
  const menu = document.getElementById('menu');
  const gameContainer = document.getElementById('game-container');
  const canvas = document.getElementById('gameCanvas');
  const hud = document.getElementById('hud');
  const backBtn = document.getElementById('backBtn');
  const ctx = canvas.getContext('2d');
  let currentGame = null;

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Запуск выбранной игры
  menu.addEventListener('click', (e) => {
    const btn = e.target.closest('.game-btn');
    if (!btn) return;
    const game = btn.dataset.game;
    startGame(game);
  });

  // Возврат в меню
  backBtn.addEventListener('click', () => {
    if (currentGame && currentGame.stop) currentGame.stop();
    currentGame = null;
    gameContainer.style.display = 'none';
    canvas.style.display = 'none';
    hud.style.display = 'none';
    menu.style.display = 'grid';
  });

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function startGame(name) {
    menu.style.display = 'none';
    gameContainer.style.display = 'block';
    canvas.style.display = 'block';
    hud.style.display = 'block';
    hud.textContent = '';
    switch(name) {
      case 'bubbles': currentGame = BubblePop(); break;
      case 'fishpond': currentGame = FishPond(); break;
      case 'zengarden': currentGame = ZenGarden(); break;
      case 'starfield': currentGame = Starfield(); break;
      case 'colorflow': currentGame = ColorFlow(); break;
    }
  }

  // === Bubble Pop ===
  function BubblePop() {
    const bubbles = [];
    const maxBubbles = 30;
    let animationId;

    function createBubble() {
      if (bubbles.length < maxBubbles) {
        bubbles.push({
          x: Math.random() * canvas.width,
          y: canvas.height + 50,
          r: 20 + Math.random() * 30,
          vy: 1 + Math.random() * 2
        });
      }
    }

    function drawBubbles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      bubbles.forEach((b, i) => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
        b.y -= b.vy;
        if (b.y < -b.r) bubbles.splice(i, 1);
      });
      hud.textContent = `Bubbles: ${bubbles.length}`;
    }

    function loop() {
      createBubble();
      drawBubbles();
      animationId = requestAnimationFrame(loop);
    }

    // Лопание пузырей кликом
    canvas.addEventListener('click', popBubble);
    function popBubble(e) {
      bubbles.forEach((b, i) => {
        const dist = Math.hypot(e.clientX - b.x, e.clientY - b.y);
        if (dist < b.r) {
          bubbles.splice(i, 1);
        }
      });
    }

    loop();

    return {
      stop() {
        cancelAnimationFrame(animationId);
        canvas.removeEventListener('click', popBubble);
      }
    };
  }

  // === Fish Pond ===
  function FishPond() {
    const fishCount = 20;
    const fish = [];
    let animationId;

    for (let i = 0; i < fishCount; i++) {
      fish.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        angle: Math.random() * Math.PI * 2,
      });
    }

    function drawFish() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      fish.forEach(f => {
        f.x += Math.cos(f.angle) * 1.5;
        f.y += Math.sin(f.angle) * 1.5;
        f.angle += (Math.random() - 0.5) * 0.1;
        if (f.x > canvas.width) f.x = 0;
        if (f.x < 0) f.x = canvas.width;
        if (f.y > canvas.height) f.y = 0;
        if (f.y < 0) f.y = canvas.height;
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate(f.angle);
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.lineTo(15, 0);
        ctx.lineTo(10, 5);
        ctx.lineTo(10, -5);
        ctx.fillStyle = '#8ce';
        ctx.fill();
        ctx.restore();
      });
      hud.textContent = `Fish: ${fish.length}`;
    }

    function loop() {
      drawFish();
      animationId = requestAnimationFrame(loop);
    }

    loop();

    return {
      stop() {
        cancelAnimationFrame(animationId);
      }
    };
  }

  // === Zen Garden ===
  function ZenGarden() {
    let drawing = false;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';

    function startDraw() { drawing = true; }
    function stopDraw() { drawing = false; }
    function draw(e) {
      if (!drawing) return;
      const x = e.clientX;
      const y = e.clientY;
      const offsetX = (Math.random() - 0.5) * 10;
      const offsetY = (Math.random() - 0.5) * 10;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + offsetX, y + offsetY);
      ctx.stroke();
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mouseup', stopDraw);
    canvas.addEventListener('mousemove', draw);
    hud.textContent = 'Draw your calm lines';

    return {
      stop() {
        canvas.removeEventListener('mousedown', startDraw);
        canvas.removeEventListener('mouseup', stopDraw);
        canvas.removeEventListener('mousemove', draw);
      }
    };
  }

  // === Starfield ===
  function Starfield() {
    const starCount = 300;
    const stars = [];
    let animationId;

    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        z: Math.random() * canvas.width
      });
    }

    function drawStars() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      stars.forEach(s => {
        s.z -= 2;
        if (s.z < 1) {
          s.x = Math.random() * canvas.width;
          s.y = Math.random() * canvas.height;
          s.z = canvas.width;
        }
        const k = 500 / s.z;
        const x = (s.x - canvas.width / 2) * k + canvas.width / 2;
        const y = (s.y - canvas.height / 2) * k + canvas.height / 2;
        const size = 2 * k;
        ctx.fillStyle = '#fff';
        ctx.fillRect(x, y, size, size);
      });
      hud.textContent = `Stars: ${starCount}`;
    }

    function loop() {
      drawStars();
      animationId = requestAnimationFrame(loop);
    }

    loop();

    return {
      stop() {
        cancelAnimationFrame(animationId);
      }
    };
  }

  // === Color Flow ===
  function ColorFlow() {
    let hue = 0;
    let animationId;

    function drawFlow() {
      ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.1)`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      hue = (hue + 1) % 360;
      hud.textContent = `Hue: ${hue}`;
    }

    function loop() {
      drawFlow();
      animationId = requestAnimationFrame(loop);
    }

    loop();

    return {
      stop() {
        cancelAnimationFrame(animationId);
      }
    };
  }
  </script>
</body>
</html>
